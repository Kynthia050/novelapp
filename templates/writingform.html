<!DOCTYPE html>
<html lang="th">
<head>
  <meta charset="utf-8" />
  <title>{% if chapter %}แก้ไขตอน{% else %}เขียนตอนใหม่{% endif %} — MY SHELF</title>

  <!-- ฟอนต์และสไตล์หลักของหน้า -->
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+Thai:wght@400;500;700&display=swap');

    :root {
      --bg:#222; --text:#eee; --panel:rgba(34,34,34,.9); --muted:#bbb;
      --line:#777; --soft:#444; --brand:#fff; --radius:16px; --shadow:0 8px 24px rgba(0,0,0,.45);
      --content-font-family: 'Noto Sans Thai', system-ui, -apple-system, 'Segoe UI', Roboto, Arial, sans-serif;
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; font-family:var(--content-font-family);
      background: var(--bg) url('/static/img/bg-login.jpg') center/cover fixed no-repeat;
      color:var(--text); line-height:1.6;
    }
    header{position:sticky;top:0;z-index:40;background:rgba(34,34,34,.85);backdrop-filter:blur(6px);border-bottom:1px solid rgba(255,255,255,.08)}
    .nav{max-width:1200px;margin:0 auto;padding:14px 20px;display:flex;align-items:center;justify-content:center;text-align:center}
    .brand{font-family: Georgia, 'Times New Roman', serif; font-size:2rem; letter-spacing:.25em; font-weight:700}
    .page{max-width:1200px;margin:0 auto;padding:28px}
    .panel{background:var(--panel);border:1px solid rgba(255,255,255,.08);border-radius:var(--radius);box-shadow:var(--shadow);padding:24px}
    .title-display{font-size:clamp(22px,3.2vw,40px);letter-spacing:.25em;margin-bottom:22px}
    .fields{display:grid;grid-template-columns:auto 1fr;gap:18px 20px;align-items:center;margin-bottom:18px}
    .label{font-size:clamp(16px,1.4vw,22px);letter-spacing:.25em}
    .pill{background:#ddd;color:#111;padding:10px 18px;border-radius:14px;min-width:64px;text-align:center}
    .input{width:100%;background:#ddd;color:#111;border:0;outline:none;border-radius:14px;padding:12px 16px;font-size:1rem}
    .editor-wrap{margin-top:12px}
    .editor-bar{
  display:flex;
  align-items:center;
  justify-content:space-between;
  margin-bottom:8px; /* keep small gap before toolbar/editor */
}
.editor-label{
  font-weight:700;
  margin-bottom:0; /* ensure label stays on the same line */
}
.preview-bar{
  margin-bottom:0; /* keep preview button vertically aligned with label */
}
    .actions{display:flex;gap:16px;justify-content:center;margin-top:22px}
    .btn{padding:12px 22px;border-radius:14px;border:1px solid var(--soft);background:#ddd;color:#111;font-weight:600;cursor:pointer}
    .btn.primary{background:var(--brand);color:#000;border-color:var(--brand)}
    .btn:hover{filter:brightness(.95)}
    @media (max-width:720px){ .fields{grid-template-columns:1fr;} .label{text-align:left} }
    .prose img { max-width:100%; height:auto; }

    /* Quill: ปรับสไตล์ให้เข้ากับธีม */
    .ql-toolbar.ql-snow{
      border:1px solid rgba(255,255,255,.15);
      border-radius:12px; background:#f3f3f3; color:#111;
    }

    /* Replace previous undo/redo styles with toolbar-consistent styles */
.ql-toolbar .ql-undo,
.ql-toolbar .ql-redo {
  color: inherit;               /* match other toolbar icons */
  background: transparent;
  border: none;
  padding: 4px;                 /* match typical toolbar button spacing */
  margin: 0 2px;
  border-radius: 6px;
  font-weight: normal;
  transition: background-color .12s, color .12s;
  line-height: 1;
}
.ql-toolbar .ql-undo:hover,
.ql-toolbar .ql-redo:hover,
.ql-toolbar button:hover {
  background: rgba(0,0,0,0.06); /* same hover feel as other toolbar buttons */
}
.ql-toolbar .ql-undo::before,
.ql-toolbar .ql-redo::before {
  color: inherit;
  font-weight: normal;
  font-size: 1em;
}
    .ql-container.ql-snow{
      border:1px solid rgba(255,255,255,.12);
      border-radius:12px; background:#fff; color:#000;
      min-height:400px;
      overflow-y:auto;
      max-height:calc(100vh - 380px);
    }
    .ql-editor{
      font-family: "Georgia", serif;
      font-size:1.1rem;
      line-height:1.8;
      min-height: 360px;
      padding:2rem;
    }
    /* Scrollbar styling */
    .ql-container::-webkit-scrollbar {
      width: 10px;
    }
    .ql-container::-webkit-scrollbar-track {
      background: #f1f1f1;
      border-radius: 4px;
    }
    .ql-container::-webkit-scrollbar-thumb {
      background: #999;
      border-radius: 4px;
    }
    .ql-container::-webkit-scrollbar-thumb:hover {
      background: #666;
    }
    /* Firefox scrollbar */
    .ql-container {
      scrollbar-color: #999 #f1f1f1;
      scrollbar-width: thin;
    }

    .ql-undo::before { content: '↶'; }
    .ql-redo::before { content: '↷'; }
  </style>

  <!-- Quill (CDN) -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/quill/dist/quill.snow.css">
</head>
<body class="dark-mode h-full font-thai text-white bg-bg"
      data-novels-id="{{ novels_id }}"
      data-chapters-id="{{ chapters_id }}">
  
  <!-- Header -->
  <header class="sticky top-0 z-30 border-b border-white/10 bg-bg/80 backdrop-blur-md">
    {% include 'header.html' %}
  </header>

  <main class="page">
    <section class="panel">
      <div class="title-display" id="novelTitle">{{ novel.title if novel else 'Unknown Novel' }}</div>

      <div class="fields">
        <div class="label">ตอนที่ :</div>
        <input type="number" id="part" min="1" value="{{ suggested_part }}" class="pill" style="width:90px" />
        <div class="label">ชื่อตอน :</div>
        <input type="text" id="epName" class="input" placeholder="ชื่อตอน (เช่น Rising Star)" value="{{ chapter.title if chapter else '' }}" />
      </div>

      <!-- ฟอร์มส่งไปบันทึกตอน -->
      <form id="chapter-form" method="POST" action="{{ url_for('writing.save_chapter') }}">
        <input type="hidden" name="csrf_token" value="{{ csrf_token() }}"/>
        <input type="hidden" name="novels_id" value="{{ novels_id }}" />
        {% if chapter %}
        <input type="hidden" name="chapter_id" value="{{ chapter.chapters_id }}" />
        {% endif %}
        <input type="hidden" name="part" id="partInput" value="1" />
        <input type="hidden" name="epName" id="epNameInput" value="" />

            <div class="editor-wrap">
        <div class="editor-bar">
          <div class="editor-label">เนื้อเรื่อง</div>

          <div class="preview-bar">
            <button class="btn" id="previewBtn" type="button">ดูตัวอย่าง</button>
          </div>
        </div>

          <!-- Toolbar ของ Quill -->
          <div id="toolbar">
            <span class="ql-formats">
              <button class="ql-undo" type="button" title="Undo"></button>
              <button class="ql-redo" type="button" title="Redo"></button>
            </span>
            <span class="ql-formats">
              <select class="ql-header">
                <option value="false" selected>ปกติ</option>
                <option value="1">หัวเรื่อง 1</option>
                <option value="2">หัวเรื่อง 2</option>
                <option value="3">หัวเรื่อง 3</option>
              </select>
            </span>
            <span class="ql-formats">
              <button class="ql-bold"></button>
              <button class="ql-italic"></button>
              <button class="ql-underline"></button>
            </span>
            <span class="ql-formats">
              <button class="ql-list" value="ordered"></button>
              <button class="ql-list" value="bullet"></button>
              <select class="ql-align"></select>
            </span>
            <span class="ql-formats">
              <button class="ql-indent" value="-1"></button>
              <button class="ql-indent" value="+1"></button>
            </span>
            <span class="ql-formats">
              <button class="ql-image"></button>
              <button class="ql-clean"></button>
            </span>
          </div>


          <!-- พื้นที่แก้ไข -->
          <div id="editor" class="prose"></div>

          <!-- ฟิลด์ที่จะโพสต์ HTML ไป backend -->
          <textarea id="chapter-content" name="content_html" required style="display:none;"></textarea>
        </div>
      </form>

      <div class="actions">
        <button class="btn" id="cancelBtn" type="button">ยกเลิก</button>
        <button class="btn primary" id="saveBtn" type="button">{% if chapter %}อัปเดต{% else %}บันทึก{% endif %}</button>
      </div>
    </section>
  </main>

  <!-- ข้อมูลจากฝั่งเซิร์ฟเวอร์ (ใช้ content_html) -->
  <script id="server-data" type="application/json">
  {
    "hasChapter": {{ (chapter is not none)|tojson }},
    "chapterContent": {% if chapter %}{{ chapter.content_html|tojson|safe }}{% else %}null{% endif %}
  }
  </script>

  <!-- Quill JS -->
  <script src="https://cdn.jsdelivr.net/npm/quill/dist/quill.min.js"></script>

  <script>
    // ===== Config สำหรับ route สำคัญ =====
        const UPLOAD_URL = "{{ url_for('writing.upload_image') }}";
        const CANCEL_FALLBACK_URL = "{{ url_for('editnovel.edit_novel', novels_id=novels_id) }}";

       // === config autosave / preview ===
    const AUTOSAVE_URL   = "{{ url_for('writing.save_chapter') }}";
    // 999999 จะถูกแทนด้วยเลขตอนจริงใน JS
    const PREVIEW_TEMPLATE = "{{ url_for('reading.read_chapter', novels_id=novels_id, chapter_no=999999) }}";

    // novels_id แปลงเป็น number จาก string ที่ Jinja ใส่ให้
    const NOVELS_ID = Number("{{ novels_id }}");

    // chapter_id: ถ้ามีตอนอยู่แล้ว Jinja จะใส่เลขให้, ถ้าไม่มีจะเป็น string ว่าง
    const currentChapterIdStr = "{{ chapter.chapters_id if chapter else '' }}";
    const currentChapterId = currentChapterIdStr ? Number(currentChapterIdStr) : null;



    
    // ===== อ่าน JSON ฝั่งเซิร์ฟเวอร์ =====
    let serverData = { hasChapter: false, chapterContent: null };
    (function() {
      const el = document.getElementById('server-data');
      if (el && el.textContent) {
        try { serverData = JSON.parse(el.textContent); } catch (e) { console.warn('Invalid server-data JSON', e); }
      }
    })();

    // ===== สร้าง Quill =====
    const quill = new Quill('#editor', {
      theme: 'snow',
      placeholder: 'เริ่มพิมพ์เนื้อหาตอนของคุณที่นี่...',
      modules: {
        toolbar: '#toolbar',
        history: { delay: 500, maxStack: 500, userOnly: true },
        keyboard: {
          bindings: {
            // Tab = indent | Shift+Tab = outdent
            tab: {
              key: 9,
              handler(range, context) {
                if (context.format['code-block']) return true;
                quill.format('indent', '+1', Quill.sources.USER);
                return false;
              }
            },
            shift_tab: {
              key: 9,
              shiftKey: true,
              handler(range, context) {
                if (context.format['code-block']) return true;
                quill.format('indent', '-1', Quill.sources.USER);
                return false;
              }
            }
          }
        }
      },
      formats: ['header','bold','italic','list','align','indent','image','clean','underline','italic']
    });

    // โหลดเนื้อหาเดิม (HTML)
    if (serverData.hasChapter && serverData.chapterContent) {
      quill.clipboard.dangerouslyPasteHTML(serverData.chapterContent);
    }

    // --- initial snapshot (ค่าก่อนผู้ใช้เริ่มแก้ไข) ---
    // เก็บค่า part / epName / HTML ที่เป็น "ล่าสุดก่อนแก้ไข" เพื่อใช้ในปุ่ม Cancel
    const initialPart = document.getElementById('part').value || '';
    const initialEpName = document.getElementById('epName').value || '';
    const initialHtml = (serverData && serverData.chapterContent) ? serverData.chapterContent : quill.root.innerHTML;

    // ===== อัปโหลดรูปจาก Quill -> /writing/upload =====
    quill.getModule('toolbar').addHandler('image', () => {
      const input = document.createElement('input');
      input.type = 'file'; input.accept = 'image/*';
      input.onchange = async () => {
        const file = input.files && input.files[0];
        if (!file) return;

        const fd = new FormData();
        fd.append('file', file);

        // แนบ CSRF token (ถ้าใช้งาน CSRFProtect)
        const csrfEl = document.querySelector('input[name="csrf_token"]');
        const csrf = csrfEl ? csrfEl.value : '';
        if (csrf) fd.append('csrf_token', csrf);

        try {
          const res = await fetch(UPLOAD_URL, {
            method: 'POST',
            body: fd,
            credentials: 'same-origin',
            headers: csrf ? { 'X-CSRFToken': csrf } : {}
          });
          const j = await res.json();
          if (j && j.url) {
            const range = quill.getSelection(true) || { index: quill.getLength(), length: 0 };
            quill.insertEmbed(range.index, 'image', j.url, 'user');
          } else {
            alert('อัปโหลดไม่สำเร็จ');
          }
        } catch (e) {
          console.error(e);
          alert('อัปโหลดไม่สำเร็จ');
        }
      };
      input.click();
    });

    // ===== Auto-save =====
    let lastAutoSavedHtml = null;
    let autoSaveTimer = null;
    let autoSaving = false;
    let dirty = false;   // ใช้ร่วมกับ beforeunload

    function scheduleAutoSave() {
      if (autoSaveTimer) clearTimeout(autoSaveTimer);
      // ตั้งเป็น 5 นาที (300000 ms) หลังหยุดพิมพ์ ก่อนจะ autosave
      autoSaveTimer = setTimeout(() => runAutoSave(false), 300000); // 5 นาทีหลังหยุดพิมพ์
    }

    async function runAutoSave(force = false) {
      autoSaveTimer = null;

      const part   = Number(document.getElementById('part').value || 0);
      const epName = (document.getElementById('epName').value || '').trim();
      const html   = quill.root.innerHTML.trim();

      const textOnly = html.replace(/<[^>]*>/g,'').replace(/&nbsp;|\s/g,'');
      const hasImage = /<img\b/i.test(html);

      // ยังไม่กรอกอะไรเลย / ไม่มีเนื้อหา → ไม่ต้อง autosave
      if (part < 1) return;
      if (!textOnly && !hasImage) return;
      // ถ้าไม่บังคับ และ HTML เหมือนกับ lastAutoSavedHtml (แล้วมี chapter_id) → ข้าม
      if (!force && html === lastAutoSavedHtml && currentChapterId) return;
      if (autoSaving) return;

      autoSaving = true;

      const fd = new FormData();
      const csrfEl = document.querySelector('input[name="csrf_token"]');
      if (csrfEl && csrfEl.value) {
        fd.append('csrf_token', csrfEl.value);
      }
      fd.append('novels_id', String(NOVELS_ID));
      if (currentChapterId) {
        fd.append('chapter_id', String(currentChapterId));
      }
      fd.append('part', String(part));
      fd.append('epName', epName);
      fd.append('content_html', html);

      try {
        const res = await fetch(AUTOSAVE_URL, {
          method: 'POST',
          body: fd,
          headers: { 'Accept': 'application/json' },
          credentials: 'same-origin'
        });
        if (!res.ok) throw new Error('status ' + res.status);
        const data = await res.json();
        if (data && data.success) {
          // ถ้าเป็นการสร้างตอนใหม่ → backend จะส่ง chapters_id กลับมา เก็บไว้ใช้ต่อ
          if (data.chapters_id && !currentChapterId) {
            currentChapterId = data.chapters_id;
            let hidden = document.querySelector('input[name="chapter_id"]');
            if (!hidden) {
              hidden = document.createElement('input');
              hidden.type = 'hidden';
              hidden.name = 'chapter_id';
              hidden.id   = 'chapter_id';
              document.getElementById('chapter-form').appendChild(hidden);
            }
            hidden.value = String(data.chapters_id);
          }
          lastAutoSavedHtml = html;
          dirty = false;  // ถือว่าข้อมูลล่าสุดถูกบันทึกแล้ว
        }
      } catch (e) {
        console.debug('auto save failed', e);
      } finally {
        autoSaving = false;
      }
    }

    // เมื่อแก้ไขเนื้อหา → mark dirty + schedule autosave
    quill.on('text-change', () => {
      dirty = true;
      scheduleAutoSave();
    });

    document.getElementById('part').addEventListener('change', () => {
      dirty = true;
      scheduleAutoSave();
    });

    document.getElementById('epName').addEventListener('input', () => {
      dirty = true;
      scheduleAutoSave();
    });

    // ออกจากหน้า ถ้ายังมีของที่ยังไม่ save ให้เตือน
    window.addEventListener('beforeunload', (e) => {
      if (dirty) {
        e.preventDefault();
        e.returnValue = '';
      }
    });


    // ===== ปุ่ม Cancel: กลับหน้าก่อนหน้า (referrer/history) หรือ fallback =====
  document.getElementById('cancelBtn').addEventListener('click', async () => {
    // ถ้ามีการแก้ไข (dirty) ให้ยืนยันแล้วคืนค่าไปเป็น snapshot ก่อนแก้ไข
    if (dirty) {
      if (!confirm('ยกเลิกการแก้ไขตอนนี้และคืนค่ากลับเป็นเดิมหรือไม่?')) return;

      // คืนค่า input และ editor เป็นค่าก่อนเริ่มแก้ไข
      try {
        document.getElementById('part').value = initialPart;
        document.getElementById('epName').value = initialEpName;
        // คืน HTML เดิม
        quill.clipboard.dangerouslyPasteHTML(initialHtml || '');
      } catch (e) {
        console.warn('restore failed', e);
      }

      // ยกเลิก timer และสถานะ dirty
      if (autoSaveTimer) { clearTimeout(autoSaveTimer); autoSaveTimer = null; }
      dirty = false;
      lastAutoSavedHtml = initialHtml || '';

      // บันทึกสภาวะที่คืนค่าไปแล้วไปยังเซิร์ฟเวอร์ (force) เพื่อให้ DB กลับสู่ค่าก่อนแก้ไข
      try {
        await runAutoSave(true);
      } catch (e) {
        console.debug('forced save after cancel failed', e);
      }

      // เสร็จแล้วไม่ต้องนำทางออก — ผู้ใช้ยังคงอยู่ที่หน้า editor
      return;
    }

    // ถ้าไม่มีการแก้ไข → พฤติกรรมเดิม: กลับหน้า referrer/history หรือ fallback
    const prev = document.referrer || "";
    const isPreviewReferrer = prev.includes("preview=1");
    if (!isPreviewReferrer) {
      if (prev && new URL(prev, location.href).origin === location.origin) {
        location.href = prev;
        return;
      }
      if (history.length > 1) {
        history.back();
        return;
      }
    }
    location.href = CANCEL_FALLBACK_URL;
  });


         // ===== ปุ่ม Preview: autosave แล้วไปอ่านโหมด Preview =====
    const previewBtn = document.getElementById('previewBtn');
    if (previewBtn) {
      previewBtn.addEventListener('click', async () => {
        // บันทึกล่าสุดลง DB ก่อน (ถ้าไม่มีเนื้อหา / part ไม่ครบ ฟังก์ชันจะ return เฉย ๆ)
        await runAutoSave();

        const part = Number(document.getElementById('part').value || 0);
        if (part < 1) {
          alert('กรุณากรอกลำดับตอนที่ถูกต้อง');
          return;
        }
        // แทน 999999 ท้าย URL ด้วยเลขตอนจริง แล้วใส่ ?preview=1
        const previewUrl = PREVIEW_TEMPLATE.replace(/999999$/, String(part)) + '?preview=1';
        window.location.href = previewUrl;   // เปิด preview ในแท็บเดียวกัน
      });
    }

    // ===== ปุ่ม Save =====
    document.getElementById('saveBtn').addEventListener('click', () => {
      const part = Number(document.getElementById('part').value || 0);
      const epName = (document.getElementById('epName').value || '').trim();
      const html = quill.root.innerHTML.trim();

      if (part < 1) { alert('กรุณากรอกลำดับตอนที่ถูกต้อง'); return; }

      const textOnly = html.replace(/<[^>]*>/g,'').replace(/&nbsp;|\s/g,'');
      const hasImage = /<img\b/i.test(html);
      if (!textOnly && !hasImage) { alert('กรุณากรอกเนื้อเรื่อง'); return; }

      document.getElementById('partInput').value = String(part);
      document.getElementById('epNameInput').value = epName;
      document.getElementById('chapter-content').value = html;

      const btn = document.getElementById('saveBtn');
      const original = btn.textContent;
      btn.textContent = '{% if chapter %}กำลังอัปเดต...{% else %}กำลังบันทึก...{% endif %}';
      btn.disabled = true;

      try {
        const form = document.getElementById('chapter-form');
        if (form.requestSubmit) form.requestSubmit();
        else form.submit();
      } catch (e) {
        console.error('Save error:', e);
        alert('เกิดข้อผิดพลาดในการบันทึก');
        btn.textContent = original;
        btn.disabled = false;
      }
    });

    // ===== Ctrl/Cmd+S เพื่อบันทึก =====
    window.addEventListener('keydown', e => {
      if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 's') {
        e.preventDefault();
        document.getElementById('saveBtn').click();
      }
    });
  </script>
</body>
</html>
